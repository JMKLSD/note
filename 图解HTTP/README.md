# 图解http
## 第一章
1. 计算机与网络设备要相互通信，双方就必须基于相同的方法。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。我们就把这种规则称为协议`protocol`
2. 像这样把与互联网关联的协议集合起来总称为`TCP/IP`。也有说法认为，`TCP/IP`是指`TCP`和`IP`这两种协议。还有一种说法认为，`TCP/IP`是在`IP`协议的通信过程中，使用到的协议族的统称。
3. `TCP/IP`协议族里重要的一点就是分层。`TCP/IP`协议族按层次分别分为以下4层：应用层、传输层、网络层和数据链路层。
4. 把`TCP/IP`层次化是有好处的。比如，**如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可**。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。（**这段同写代码一样**）
5. **层次化之后，设计也变得相对简单了。处于应用层上的应用可以只考虑分派给自己的任务，而不需要弄清对方在地球上哪个地方、对方的传输路线是怎样的、是否能够确保传输送达等问题。**（**这段同MV\*模式**）
6. TCP/IP协议族各层的作用：
- 应用层
    - 应用层决定了向用户提供应用服务时通信的活动。如FTP、DNS等。**HTTP协议也处于该层。**
- 传输层
    - 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。*TCP*
- 网络层
    - 网络层用来处理在网络上流动的数据包。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。 与对方计算机之间通过多台计算机或网络设备传输时，网络层提供的作用就是在众多的选项内提供一条传输路线。**IP**
- 链路层
    - 用来处理连接网络的硬件部分。**网络**
7. 发送端在层与层传送数据时，会被打上该层所属的首部信息。接收端在层与层之间会把对应的首部消去。这种把数据信息包装起来的做法称为封装。
8. TCP协议采用了三次握手策略。发送端首先发送一个带有SYN标志的数据包给对方，接收端收到后，回传一个SYN/ACK标志的数据包以示传达确认信息。最后发送端再回传一个带ACK标志的数据包，代表握手结束。
9. **DNS（Domain Name System）提供域名到IP地址之间的解析服务。**
一般用户都是通过域名来访问的，而不是通过IP地址来访问，因为记住一串数字比较难。但是让计算机去理解名称就比较困难了，所以DNS服务应运而生。通过域名来查找地址，然后反馈一个IP地址。
    - 发送端输入网址
    - DNS返回一个IP地址
    - 发送端用IP地址来进行访问。
10. URI（统一资源标识符）；URL（统一资源定位符）；URI用字符串标识某一互联网资源；URL表示资源的地点；URL是URI的子集；

## 第二章
1. HTTP协议用于客户端和服务端之间的通信
2. 方法：
- GET，获取资源，get方法用来请求访问已被uri识别的资源。
- POST，传输实体主题。
- PUT，用来传输文件，要求在请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。由于put方法本身不带验证机制，任何人都能够上传文件，存在安全问题，因此一般的web网站不适用该方法。
- HEAD：获得报文首部（跟GET一样，只是不返回报文主体部分）
- DELETE：删除文件（是与PUT相反的方法）
- OPTIONS：options方法用来查询针对请求uri指定的资源支持的方法
- TRACE：追踪路径，用来确认连接过程中发生的一系列操作。不常用，而且容易引发XST攻击。
- CONNECT：要求用隧道协议连接代理，实现用隧道协议进行TCP通信。主要使用SSL和TLS协议把通信内容进行加密后经网络隧道传输。
4. 方法区分大小写，用大写来表示；
5. 在http协议的初始版本里，每进行一次HTTP通信就要断开一次TCP连接；为了解决TCP连接的问题，有了持久连接（http  keep-alive），也就是只要建立连接就能一次性发送请求的资源了；而管线化能做到同事并行发送多个请求，而不需要一个接一个地等待响应了，这样大大提高了效率。
6. 保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了cookie技术。Cookie技术通过在请求和响应报文中写入cookie信息来控制客户端的状态。
7. Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送过去。
8. 服务端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客服端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。